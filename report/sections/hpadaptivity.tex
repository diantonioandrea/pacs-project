\subsection{Estimating the decay rate of the Legendre coefficients}

Having tested the \textit{h-adaptive} refinement capabilities for this $DG$ implementation, the next and final step is to implement \textit{p-adaptive} refinement using a test of analyticity.

\cite{Eibner2007} Since the solution is represented by the coefficients of Legendre polynomials, analyticity can be assessed by evaluating their rate of decay.

Given \eqref{decomposition}, the following relation can be written for every element $K$:

\begin{gather}
    u^{k, ij}_{h, K} = c_{ij} \phi_{ij} \quad \Forall i, j : i + j = k.
\end{gather}

Assuming smoothness for $u^k_{h, K}$, the following holds:

\begin{gather}
    \Exists a_K, b_K \in \R : c_{ij} \approx a_K e^{-b_K (i + j)}.
\end{gather}

An estimate of $b_K$ through a linear fit of $\log(\lvert c_{ij} \rvert)$ is the key to choosing \textit{p-refinement} over \textit{h-refinement}. In fact, $u^k_{h, K}$ is said to be smooth if $b_K$ exceeds a certain threshold, fixed to $1.5$ in the following numerical tests.

The marking strategy is slightly modified so that the elements $K$ to be refined are chosen in the following way:

\begin{gather}
    \eta_K^2 > \sigma \bar{\eta}^2,
\end{gather}

where:

\begin{gather}
    \bar{\eta}^2 = \frac{1}{\lvert \Tau \rvert} \sum_{K \in \Tau} \eta_K^2.
\end{gather}

Due to:

\begin{gather}
    \kappa(\MA) \approx k^4 h^{-2},
\end{gather}

the \textit{hp-adaptive} code uses an expensive preconditioned solver based on the inverse of the diagonal block part of $\MA$. This is why the following example starts with a coarser mesh.

\newpage
\subsubsection{Error and meshes}



\newpage
\subsection{A code snippet}

Here's a snippet to illustrate the \textit{hp-adaptive} mesh refinement from the user's perspective:

\lstinputlisting[style=cpp, firstline=11]{../snippets/hp_refine.cpp}