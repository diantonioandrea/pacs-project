\subsection{\textit{h-Adaptivity}}

\begin{frame}[fragile]
    \frametitle{\textit{h-Adaptivity}}

    To implement \textit{h-adaptivity}, the first step is to evaluate the $\LT$ error on each element.

    The elements $K$ to be refined are selected as follows:

    \begin{gather}
        \eta_K > \sigma \eta_{M},
    \end{gather}

\end{frame}

\begin{frame}[fragile]
    \frametitle{Refinement}

    The function \lstinline{mesh_refine_size} refines the mesh elements based on the local errors according to a specific refinement strategy.

    \begin{lstlisting}[style=cpp]
    void mesh_refine_size(
        Mesh &, 
        const Mask &);
    \end{lstlisting}

\end{frame}

\subsection{\textit{hp-Adaptivity}}

\begin{frame}
    \frametitle{\textit{hp-Adaptivity}}

    The next and final step is to implement \textit{p-adaptive} refinement using a test of analyticity.

    Analyticity can be assessed by evaluating the rate of decay of Legendre coefficients. Assuming smoothness for $u^k_{h, K}$, the following relationship holds:

    \begin{gather}
        \Exists a_K, b_K \in \R : c_{ij} \approx a_K e^{-b_K (i + j)}.
    \end{gather}

    The elements $K$ to be refined are selected as follows:

    \begin{gather}
        \eta_K^2 > \sigma \bar{\eta}^2,
    \end{gather}

\end{frame}

\begin{frame}[fragile]
    \frametitle{Refinement}

    The function \lstinline{mesh_refine} refines the mesh elements based on local errors, according to a specified refinement strategy.

    \begin{lstlisting}[style=cpp]
    void mesh_refine(
        Mesh &, 
        const Estimator &, 
        const Real &refine = 0.75, 
        const Real &speed = 1.0);

    void mesh_refine_degree(
        Mesh &, 
        const Mask &);
    \end{lstlisting}

\end{frame}

\subsection{Estimates}

\begin{frame}[fragile]
    \frametitle{Estimates}

    Estimates are computed using the \lstinline{Estimators} class, instantiated as follows:

    \begin{lstlisting}[style=cpp]
    Estimator(
        const Mesh &, 
        const Sparse<Real> &, 
        const Vector<Real> &, 
        const Functor &, 
        const Functor &dirichlet
            = Functor{}, 
        const TwoFunctor &dirichlet_gradient
            = TwoFunctor{}, 
        const Real &penalty_coefficient = 10.0);
    \end{lstlisting}

\end{frame}

\subsection{Code examples}

\begin{frame}[fragile]
    \frametitle{A code snippet}

    The steps to \textit{hp-refine} a mesh are outlined as follows:

    \begin{lstlisting}[style=cpp]
    [...]

    auto [M, A, DGA] = laplacian(mesh);
    Vector<Real> B = forcing(mesh, source);

    Vector<Real> numerical = lapsolver(mesh, A, B);
    Estimator est{mesh, M, numerical, source};

    mesh_refine(mesh, est);
    \end{lstlisting}

\end{frame}