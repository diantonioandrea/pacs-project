\subsection{Building the Poisson problem}

\begin{frame}[fragile]
    \frametitle{Building the Poisson problem}

    The Poisson problem can be solved by first building the problem's matrix $\MA$ and the forcing term $\VB$.

\begin{lstlisting}[style=cpp]
std::array<Sparse<Real>, 3> laplacian(
    const Mesh &, 
    const Real &penalty_coefficient = 10.0);

Vector<Real> forcing(
    const Mesh &, 
    const Functor &, 
    const Functor &dirichlet = Functor{}, 
    const Real &penalty_coefficient = 10.0);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{\lstinline{laplacian} and \lstinline{forcing}}

    The \lstinline{laplacian} function constructs the problem's matrix $\MA$, the mass matrix $\MM$, and the $DG$ matrix $\mathcal{V}_{DG} + \mathcal{S}_{DG}$ for error evaluation. It iterates over all elements, performing the needed quadrature operations.

    Similarly, the \lstinline{forcing} function constructs the forcing term $\VB$, while also enforcing Dirichlet boundary conditions.

    Gauss-Legendre quadrature is applied, with nodes and weights generated by \lstinline{gauss_legendre}:

\begin{lstlisting}[style=cpp]
std::array<Vector<Real>, 2> gauss_legendre(
    const Real &, 
    const Real &, 
    const std::size_t &);
\end{lstlisting}
\end{frame}

\subsection{Solving the Poisson problem}

\begin{frame}[fragile]
    \frametitle{Sparse iterative solvers}

    The primary iterative solvers applied to $\MA$ are \lstinline{BICGSTAB} and \lstinline{GMRES}:

\begin{lstlisting}[style=cpp]
template<NumericType T> Vector<T> _bicgstab(
    const Sparse<T> &, 
    const Vector<T> &, 
    const Real &TOL = 1E-8);

template<NumericType T> Vector<T> _gmres(
    const Sparse<T> &, 
    const Vector<T> &, 
    const Real &TOL = 1E-8);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Sparse direct solvers}

    The direct solver applied to $\MM$ is \lstinline{DB}:

\begin{lstlisting}[style=cpp]
template<NumericType T> Vector<T> _db(
    const Sparse<T> &, 
    const Vector<T> &, 
    const std::vector<
        std::array<
            std::vector<std::size_t>, 2>> &);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Sparse preconditioners}

    When needed, the preconditioner applied to $\MA$ is \lstinline{DBI}:

\begin{lstlisting}[style=cpp]
template<NumericType T> Sparse<T> _dbi(
    const Sparse<T> &, 
    const std::vector<
        std::array<
            std::vector<std::size_t>, 2>> &);
\end{lstlisting}

    As part of \lstinline{lapsolver}:

\begin{lstlisting}[style=cpp]
Vector<Real> lapsolver(
    const Mesh &, 
    const Sparse<Real> &, 
    const Vector<Real> &, 
    const Real &TOL = 1E-15);
\end{lstlisting}
\end{frame}

\subsection{Code examples}

\begin{frame}[fragile]
    \frametitle{A code snippet}

    The steps to build and solve the Poisson problem are outlined as follows:

\begin{lstlisting}[style=cpp]
[...]

auto [M, A, DGA] = laplacian(mesh);
Vector<Real> B = forcing(
    mesh, source, dirichlet);

Vector<Real> num = solve(A, B);
Error error{
    mesh, {M, DGA}, 
    num, exact, {exact_x, exact_y}};
\end{lstlisting}

\end{frame}