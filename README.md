# Advanced Programming for Scientific Computing - Project

_The hp-Adaptive Discontinuous Galërkin Method_

## Table of Contents

- [Introduction](#introduction)
- [Overview](#overview)
- [Setup](#setup)
    - [Cloning the Repository](#cloning-the-repository)
    - [Compilation and Execution](#compilation-and-execution)
    - [Compiling the Report](#compiling-the-report)
- [Using the Reporitory](#using-the-repository)
- [Using the Code](#using-the-code)
    - [Generating a Mesh](#generating-a-mesh)
    - [Solving the Poisson Problem](#solving-the-poisson-problem)
    - [Mesh Refinement](#mesh-refinement)
- [Notes to the Reader](#notes-to-the-reader)
    - [On the Custom Laplacian Solver](#on-the-custom-laplacian-solver)

:warning: Make sure to take a look at [Notes to the Reader](#notes-to-the-reader) as they provide insight into some design choices about the code.

## Introduction

This repository presents an implementation of the hp-adaptive discontinuous Galërkin method applied to the Poisson problem.

## Overview

The key directories are as follows:

- `include/`: Holds definitions for the structures and methods utilized in the repository.
    - `include/Algebra/`: Structures and methods for vectors, matrices and linear solvers.
    - `include/Geometry/`: Tools for working with polygons and meshes.
    - `include/Fem/`: Finite element structures and methods.
    - `include/Laplacian/`: Implementation details for the Poisson problem.
- `src/`: Contains the primary implementations for the repository’s structures and methods.
- `data/`: Includes sample meshes for simple domains.
- `domains/`: Stores scripts for generating sample meshes.
- `example/`: Provides the main examples for using the repository.
- `snippets/`: Simpler examples for the report.
- `test/`: Contains scripts for testing fundamental features.
- `scripts/`: Contains Python scripts for meshes, solutions and errors visualization.
- `templates/`: Contains TikZ templates.
- `report/`: Contains a LaTeX report.

## Setup

### Cloning the Repository

Clone the repository from [here](https://github.com/diantonioandrea/pacs-project):

```bash
git clone git@github.com:diantonioandrea/pacs-project.git
```

### Compilation and Execution

The code is written to work with the C++ standard library. It has an optional dependency on _OpenMP_. The `Makefile` is designed to check for the presence of modules or a custom installation of _OpenMP_ using the definition of `$(OpenMP)` set to `/path/to/libomp`.

Compile everything[^compilation] with:

[^compilation]: The `-j` option is advised.

```bash
make
```

Compile examples with:

```bash
make examples
```

Compile tests with:

```bash
make tests
```

Compile mesh generation scripts with:

```bash
make domains
```

Executables are located in `executables/` and their outputs in `output/`.

### Compiling the Report

The report for the project can be compiled by:

```bash
cd report
make
```

## Using the Repository

Here is a brief guide on using the executables in this repository. Note that tests were written solely to verify specific parts of the code, so their usage is not covered here.

All output generated by the following codes is located in the `output/` directory.

### Domains

Codes written under `domains/` have the purpose of generating meshes over the domains used for testing the code, specifically the square and L-shaped domains.

This repository provides the following codes:

- `square_domain`
- `lshape_domain`

For example, usage would look like:

```bash
./executables/square_domain 250
```

This command generates a square mesh over $[0, 1] \times [0, 1]$ with $N = 250$.

```bash
./executables/lshape_domain 125
```

This command generates an L-shaped mesh over $[-1, 1] \times [-1, 1] \setminus [0, 1] \times [-1, 0] $ with $N = 125$.

### Examples

Examples are divided into the following categories based on their domains and meshes:

1. Uniform meshes:
    - `square_smooth.cpp`
    - `square.cpp`
    - `lshape_smooth.cpp`
    - `lshape.cpp`
2. _h-adaptively_ refined meshes with _a priori_ estimates based on $L^2$ error:
    - `square_h.cpp`
    - `lshape_h.cpp`
3. _h-adaptively_ refined meshes with _a priori_ estimates based on $H^1$ error:
    - `square_gh.cpp`
    - `lshape_gh.cpp`
4. _h-adaptively_ refined meshes with _a posteriori_ estimates:
    - `square_eh.cpp`
    - `lshape_eh.cpp`
5. _hp-adaptively_ refined meshes with _a posteriori_ estimates:
    - `square_hp.cpp`
    - `lshape_hp.cpp`

Category _1_ requires the user to specify the polynomial degree. An example command is:

```bash
./executables/square.cpp 3
```

Categories _2, ..., 5_ require the user to specify the polynomial degree and optionally a starting mesh identified by its elements. An example command is:

```bash
./executables/square_h.cpp 3 250
```

The polynomial degree specified for _hp-adaptively_ refined meshes is treated as the starting degree.

## Using the Code

### Mesh Generation

To generate a mesh, include `<Geometry.hpp>` which provides all necessary tools.

Start by defining a domain using points:

```cpp
pacs::Point a{0.0, 0.0};
pacs::Point b{1.0, 0.0};
pacs::Point c{1.0, 1.0};
pacs::Point d{0.0, 1.0};

pacs::Polygon domain{{a, b, c, d}};
```

Next, create a diagram with 100 elements over the square domain:

```cpp
std::vector<pacs::Polygon> diagram = pacs::mesh_diagram(domain, 100);
```

Generate a mesh and save it to a `.poly` file:

```cpp
pacs::Mesh mesh{domain, diagram};
mesh.write("output/square.poly");
```

The diagram can be retrieved using the same `mesh_diagram` function:

```cpp
std::vector<pacs::Polygon> retrieved = pacs::mesh_diagram("output/square.poly");
```

For non-convex domains, enable point reflection:

```cpp
std::vector<pacs::Polygon> diagram = pacs::mesh_diagram(domain, 100, reflect=true);
```

### Solving the Poisson Problem

To solve the Poisson problem, ensure you have included `<Fem.hpp>` and `<Laplacian.hpp>` for necessary functionalities.

First, build the Laplacian matrix from your mesh[^laplacian][^real]:


[^laplacian]: `laplacian` also builds some other matrices used for error evaluation.
[^real]: `pacs::Real` wraps `long double`.

```cpp
std::array<pacs::Matrix<pacs::Real>, 3> matrices = pacs::laplacian(mesh);
pacs::Matrix<pacs::Real> laplacian = matrices[1];
```

Next, construct the forcing term using specified source and Dirichlet boundary conditions:

```cpp
pacs::Vector<pacs::Real> forcing = pacs::forcing(mesh, source, dirichlet);
```

Here, `source` and `dirichlet` are functions representing the source term and Dirichlet boundary conditions, respectively, which follow the following scheme:

```cpp
pacs::Real function(const pacs::Real &, const pacs::Real &);
```

Finally, solve the linear system to find the solution vector:

```cpp
pacs::Vector<pacs::Real> solution = pacs::solve(laplacian, forcing);
```

This `solution` vector now contains the computed solution to the Poisson problem on the given mesh with specified boundary conditions and source term.

### Mesh refinement

After solving the Poisson problem, you can evaluate _a posteriori_ error estimates, allowing for adaptive mesh refinement.

First, evaluate the estimates:

```cpp
pacs::Estimator estimator{mesh, M, numerical, source, dirichlet, {dirichlet_x, dirichlet_y}};
```

Pass the current mesh, the mass matrix, the source, and the Dirichlet boundary condition along with its derivatives to the `pacs::Estimator` constructor.

Use the `mesh_refine` function to _hp-refine_ the mesh:

```cpp
mesh_refine(mesh, estimator);
```

## Notes to the Reader

### On the Custom Laplacian Solver

All the adaptive examples use `pacs::lapsolver` instead of a manual `pacs::solve`. This is a wrapper for `GMRES` with a `DBI`[^dbi] preconditioner, which is particularly useful given the ill-conditioning that _hp-adaptive_ methods suffer from.

[^dbi]: A generic name for a Block-Jacobi preconditioner.