# Advanced Programming for Scientific Computing - Project

_hp-Adaptive Discontinuous Galërkin Algorithms_

## Table of Contents

- [Introduction](#introduction)
- [Overview](#overview)
- [Setup](#setup)
    - [Cloning the Repository](#cloning-the-repository)
    - [Compilation and Execution](#compilation-and-execution)
    - [Compiling the Report](#compiling-the-report)
- [Using the Reporitory](#using-the-repository)
- [Using the Code](#using-the-code)
    - [Generating a Mesh](#generating-a-mesh)
    - [Solving the Poisson Problem](#solving-the-poisson-problem)
    - [Mesh Refinement](#mesh-refinement)

## Introduction

This repository presents an implementation of an hp-adaptive discontinuous Galërkin method.

## Overview

The key directories are as follows:

- `include/`: Holds definitions for the structures and methods utilized in the repository.
    - `include/Algebra/`: Structures and methods for vectors, matrices and linear solvers.
    - `include/Geometry/`: Tools for working with polygons and meshes.
    - `include/Fem/`: Finite element structures and methods.
    - `include/Laplacian/`: Implementation details for the Poisson problem.
- `src/`: Contains the primary implementations for the repository’s structures and methods.
- `data/`: Includes sample meshes for simple domains.
- `domains/`: Stores scripts for generating sample meshes.
- `example/`: Provides the main examples for using the repository.
- `snippets/`: Simpler examples for the report.
- `test/`: Contains scripts for testing fundamental features.
- `scripts/`: Contains Python scripts for meshes, solutions and errors visualization.
- `templates/`: Contains TikZ templates.

## Setup

### Cloning the Repository

Clone the repository from [here](https://github.com/diantonioandrea/pacs-project):

```bash
git clone git@github.com:diantonioandrea/pacs-project.git
```

### Compilation and Execution

Compile examples with:

```bash
make examples
```

Compile tests with:

```bash
make tests
```

Compile mesh generation scripts with:

```bash
make domains
```

Executables are located in `executables/` and their outputs in `output/`.

### Compiling the Report

The report for the project can be compiled by:

```bash
cd report
make
```

## Using the Repository

Here is a brief guide on using the executables in this repository. Note that tests were solely to verify specific parts of the code, so their usage is not covered here.

All output generated by the following codes is located in the `output/` directory.

### Domains

Codes written under `domains/` have the purpose of generating meshes over the domains used for testing the code, specifically the square and L-shaped domains.

This repository provides the following codes:

- `square_domain`
- `lshape_domain`

For example, usage would look like:

```bash
./executables/square_domain 250
```

This command generates a square mesh over $[0, 1] \times [0, 1]$ with $N = 500$.

### Examples

Examples are divided into the following categories based on their domains and meshes:

1. Uniform meshes:
    - `square_smooth.cpp`
    - `square.cpp`
    - `lshape_smooth.cpp`
    - `lshape.cpp`
2. _h-adaptively_ refined meshes with _a priori_ estimates based on $L^2$ error:
    - `square_h.cpp`
    - `lshape_h.cpp`
3. _h-adaptively_ refined meshes with _a priori_ estimates based on $H^1$ error:
    - `square_gh.cpp`
    - `lshape_gh.cpp`
4. _h-adaptively_ refined meshes with _a posteriori_ estimates:
    - `square_eh.cpp`
    - `lshape_eh.cpp`
5. _hp-adaptively_ refined meshes with _a posteriori_ estimates:
    - `square_hp.cpp`
    - `lshape_hp.cpp`

Category _1_ requires the user to specify the polynomial degree. An example command is:

```bash
./executables/square.cpp 3
```

Categories from _2, ..., 5_ require the user to specify the polynomial degree and a starting mesh identified by its elements. An example command is:

```bash
./executables/square_h.cpp 3 250
```

## Using the Code

### Mesh Generation

To generate a mesh, include `<Geometry.hpp>` which provides all necessary tools.

Start by defining a domain using points:

```cpp
pacs::Point a{0.0, 0.0};
pacs::Point b{1.0, 0.0};
pacs::Point c{1.0, 1.0};
pacs::Point d{0.0, 1.0};

pacs::Polygon domain{{a, b, c, d}};
```

Next, create a diagram with 100 elements over the square domain:

```cpp
std::vector<pacs::Polygon> diagram = pacs::mesh_diagram(domain, 100);
```

Generate a mesh and save it to a `.poly` file:

```cpp
pacs::Mesh mesh{domain, diagram};
mesh.write("output/square.poly");
```

The diagram can be retrieved using the same `mesh_diagram` function:

```cpp
std::vector<pacs::Polygon> retrieved = pacs::mesh_diagram("output/square.poly");
```

For non-convex domains, enable point reflection:

```cpp
std::vector<pacs::Polygon> diagram = pacs::mesh_diagram(domain, 100, reflect=true);
```

### Solving the Poisson Problem

To solve the Poisson problem, ensure you have included `<Fem.hpp>` and `<Laplacian.hpp>` for necessary functionalities.

First, build the Laplacian matrix from your mesh[^1][^2]:

[^1]: `laplacian` also builds some other matrices used for error evaluation.
[^2]: `pacs::Real` wraps `long double`.

```cpp
std::array<pacs::Matrix<pacs::Real>, 3> matrices = pacs::laplacian(mesh);
pacs::Matrix<pacs::Real> laplacian = matrices[1];
```

Next, construct the forcing term using specified source and Dirichlet boundary conditions:

```cpp
pacs::Vector<pacs::Real> forcing = pacs::forcing(mesh, source, dirichlet);
```

Here, `source` and `dirichlet` are functions representing the source term and Dirichlet boundary conditions, respectively, which follow the following scheme:

```cpp
pacs::Real function(const pacs::Real &, const pacs::Real &);
```

Finally, solve the linear system to find the solution vector:

```cpp
pacs::Vector<pacs::Real> solution = pacs::solve(laplacian, forcing);
```

This `solution` vector now contains the computed solution to the Poisson problem on the given mesh with specified boundary conditions and source term.

### Mesh refinement

After solving the Poisson problem, you can evaluate _a posteriori_ error estimates, allowing for adaptive mesh refinement.

First, evaluate the estimates:

```cpp
pacs::Estimator est{mesh, M, numerical, source, dirichlet, {dirichlet_x, dirichlet_y}};
pacs::Vector<pacs::Real> estimates = est.estimates;
```

Pass the current mesh, the mass matrix, the source, and the Dirichlet boundary condition along with its derivatives to the `pacs::Estimator` constructor.

Choose a refinement strategy of your liking and use the `mesh_refine_size` function to refine the mesh:

```cpp
mesh_refine_size(mesh, estimates > 0.75 * max(estimates));
```